{"type":"doc","filename":"devon4j.wiki_devon4j.asciidoc_guides_2.html","anchor":"guide-quarkus-configuration.asciidoc","title":"Configuration","breadcrumbs":["Java","Quarkus","Guides"],"text":"Configuration\n\nQuarkus provides a comprehensive guide to configuration here.\n\n\nExternal Application Configuration\n\nDatabase Configuration\n\nIn Quarkus, Hibernate is provided by the quarkus-hibernate-orm extension. Ensure the extension is added to your pom.xml as follows:\n\n\n\n\n\n\n\nYou additionally have to add the respective JDBC driver extension to your pom.xml. There are different drivers for different database types. See Quarkus Hibernate guide.\n\n\n\nDatabase System and Access\n\nYou need to configure which database type you want to use, as well as the location and credentials to access it. The defaults are configured in application.properties. The file should therefore contain the properties as in the given example:\n\n\n\n\n\n\n\n\nDatabase Logging\n\nAdd the following properties to application.properties to enable logging of database queries for debugging purposes.\n\n\n\n\n\n\n\n\n\nSecurity\n\nPassword Encryption\n\nThere is also some libraries to make Jasypt work with Quarkus such as Camel Quarkus Jasypt. Unfortunately, this feature only works in JVM mode and not in native mode.\n\n\nQuarkus supports many credentials provider with official extensions such as HashiCorp Vault.\n\n\n\n\n\n\n\nA detailed guide can be found here and here.\n\n\n\n\nSpring Native vs Quarkus\n\nNowadays, it is very common to write an application and deploy it to a cloud.\nServerless computing and Function-as-a-Service (FaaS) have become\nvery popular.\nWhile many challenges arise when deploying a Java application into the latest cloud environment, the biggest challenges facing developers are memory footprint and the startup time required\nfor the Java application, as more of these keeps the hostâ€™s costs high in public clouds and Kubernetes clusters. With the introduction of frameworks like micronaut and microprofile, Java processes are getting faster and more lightweight. In a similar context, Spring has introduced\nSpring Native which aims to solve the big memory footprint of Spring and its slow startup time to potentially rival the new framework called Quarkus, by Red Hat. This document briefly discusses both of these two frameworks and their potential suitability with devonfw.\n\n\nQuarkus\n\nQuarkus is a full-stack, Kubernetes-native Java framework made for JVMs. With its container-first-philosophy and its native compilation with GraalVM, Quarkus optimizes Java for containers with low memory usage and fast startup times.\n\n\nQuarkus achieves this in the following ways:\n\n\n\n\nFirst Class Support for GraalVM\n\n\nBuild Time Metadata Processing: As much processing as possible is\ndone at build time, so your application will only contain the classes\nthat are actually needed at runtime. This results in less memory usage,\nand also faster startup time, as all metadata processing has already been\ndone.\n\n\nReduction in Reflection Usage: Quarkus tries to avoid reflection as much as possible in order to reduce startup time and memory usage.\n\n\nNative Image Pre Boot: When running in a native image, Quarkus\npre-boots as much of the framework as possible during the native image\nbuild process. This means that the resulting native image has already\nrun most of the startup code and serialized the result into the\nexecutable, resulting in an even faster startup-time.\n\n\n\n\nThis gives Quarkus the potential for a great platform for serverless cloud and Kubernetes environments. For more information about Quarkus and its support for devonfw please refer to the Quarkus introduction guide.\n\n\n\nSpring Native\n\n\n\nThe current version of Spring Native 0.10.5 is designed to be used with Spring Boot 2.5.6\n\n\n\n\nLike Quarkus, Spring Native provides support for compiling Spring applications to native executables using the GraalVM native-image compiler deisgned to be packaged in lightweight containers.\n\n\nSpring Native is composed of the following modules:\n\n\n\n\nspring-native: runtime dependency required for running Spring Native, provides also Native hints API.\n\n\nspring-native-configuration: configuration hints for Spring classes used by Spring AOT plugins, including various Spring Boot auto-configurations.\n\n\nspring-native-docs: reference guide, in format.\n\n\nspring-native-tools: tools used for reviewing image building configuration and output.\n\n\nspring-aot: AOT transformation infrastructure common to Maven and Gradle plugins.\n\n\nspring-aot-test: Test-specific AOT transformation infrastructure.\n\n\nspring-aot-gradle-plugin: Gradle plugin that invokes AOT transformations.\n\n\nspring-aot-maven-plugin: Maven plugin that invokes AOT transformations.\n\n\nsamples: contains various samples that demonstrate features usage and are used as integration tests.\n\n\n\n\n\nNative compilation with GraalVM\n\nQuarkus and Spring Native both use GraalVM for native compilation. Using a native image provides some key advantages, such as instant startup, instant peak performance, and reduced memory consumption. However, there are also some drawbacks: Creating a native image is a heavy process that is slower than a regular application. A native image also has fewer runtime optimizations after its warmup. Furthermore, it is less mature than the JVM and comes with some different behaviors.\n\n\nKey characteristics:\n\n\n\n\nStatic analysis of the application from the main entry point is\nperformed at build time.\n\n\nUnused parts are removed at build time.\n\n\nConfiguration required for reflection, resources, and dynamic proxies.\n\n\nClasspath is fixed at build time.\n\n\nNo class lazy loading: everything shipped in the executables will be loaded in memory on startup.\n\n\nSome code will run at build time.\n\n\n\n\nThere are limitations around some aspects of Java applications that are not fully supported\n\n\n\nBuild time and start time for apps\n\n\n\n\n\n\n\n\nFramework\nbuild time\nstart time\n\n\n\n\nSpring Native\n19.615s\n2.913s\n\n\nQuarkus Native executable\n52.818s\n0.802s\n\n\n\n\n\nMemory footprints\n\n\n\n\n\n\n\nFramework\nmemory footprint\n\n\n\n\nSpring Native\n109 MB\n\n\nQuarkus Native executable\n75 MB\n\n\n\n\n\nConsidering devonfw best practices\n\nAs of now, devonfw actively supports Spring but not Spring Native.\nAlthough Quarkus has been released to a stable release in early 2021, it has been already used in multiple big projects successfully showing its potential to implement cloud native services with low resource consumption matching the needs of scalability and resilience in cloud native environments.\nWith major stakeholders behind the open source community like Red Hat, its development and growth from its kickoff to the current state is very impressive and really shows the market needs and focus.\nAnother big advantage of Quarkus is that it started on a green field and therefore did not need to circumvent main pillars of the spring framework like reflection, being able to take clean and up-to-date design decisions not needing to cope with legacy issues.\nNonetheless, there is a experimental support also for some spring libraries already available in Quarkus, which make switching from spring to Quarkus much more easier if needed.\nWe also provide a guide\nfor Spring developers who want to adopt or try Quarkus for their\n(next) projects as it really has some gamechanging advantages over\nSpring.\n\n\n\nGeneral recommendations and conclusion\n\nQuarkus and Spring Native both have their own use cases. Under the consideration of the limitations of GraalVM to be used for native images built by Quarkus and Spring Native, there is a strong recommendation towards Quarkus from devonfw.\nOne essential differentiation has to be made on the decision for native or against native applications - the foreseen performance optimization of the JIT compiler of the JVM, which is not available anymore in a native image deployment.\nFor sure, both component frameworks will also run on a JVM getting advantage again from JIT compilation, but depending on the overall landscape then, it is recommended to stay with the knowledge of the available teams, e.g. continue making use of devon4j based on spring or even if already in that state also here make use of Quarkus on JVM.\n\n\n\n\n\n\n"}