{"type":"doc","filename":"devon4j.wiki_devon4j.asciidoc_guides.html","anchor":"guide-service-client.asciidoc","title":"Service Client","breadcrumbs":["Java","Spring","Guides"],"text":"Service Client\n\nThis guide is about consuming (calling) services from other applications (micro-services). For providing services see the Service-Layer Guide. Services can be consumed in the client or the server. As the client is typically not written in Java you should consult the according guide for your client technology. In case you want to call a service within your Java code this guide is the right place to get help.\n\n\nMotivation\n\nVarious solutions already exist for calling services such as RestTemplate from spring or the JAX-RS client API. Further each and every service framework offers its own API as well. These solutions might be suitable for very small and simple projects (with one or two such invocations). However, with the trend of microservices the invocation of a service becomes a very common use-case that occurs all over the place. You typically need a solution that is very easy to use but supports flexible configuration, adding headers for authentication, mapping of errors from server, logging success/errors with duration for performance analysis, support for synchronous and asynchronous invocations, etc. This is exactly what this devon4j service-client solution brings for you.\n\n\n\nDependency\n\nYou need to add (at least one of) these dependencies to your application:\n\n\n\n\n\n\n\n\nFeatures\n\nWhen invoking a service you need to consider many cross-cutting aspects. You might not think about them in the very first place and you do not want to implement them multiple times redundantly. Therefore you should consider using this approach. The following sub-sections list the covered features and aspects:\n\n\nSimple usage\n\nAssuming you already have a Java interface MyService of the service you want to invoke:\n\n\n\n\n\n\n\nThen all you need to do is this:\n\n\n\n\n\n\n\nAs you can see both synchronous and asynchronous invocation of a service is very simple and type-safe. Still it is very flexible and powerful (see following features). The actual call of myMethod will technically call the remote service over the wire (e.g. via HTTP) including marshaling the arguments (e.g. converting myArgs to JSON) and unmarshalling the result (e.g. converting the received JSON to myResult).\n\n\nAsynchronous Invocation of void Methods\n\nIf you want to call a service method with void as return type, the type-safe call method can not be used as void methods do not return a result. Therefore you can use the callVoid method as following:\n\n\n\n\n\n\n\nYou may also provide null as resultHandler for \"fire and forget\". However, this will lead to the result being ignored so even in case of an error you will not be notified.\n\n\n\n\nConfiguration\n\nThis solution allows a very flexible configuration on the following levels:\n\n\n\n\nGlobal configuration (defaults)\n\n\nConfiguration per remote service application (microservice)\n\n\nConfiguration per invocation.\n\n\n\n\nA configuration on a deeper level (e.g. 3) overrides the configuration from a higher level (e.g. 1).\n\n\nThe configuration on Level 1 and 2 are configured via application.properties\n(see configuration guide).\nFor Level 1 the prefix service.client.default. is used for properties.\nFurther, for level 2. the prefix service.client.app.«application». is used where «application» is the\ntechnical name of the application providing the service. This name will automatically be derived from\nthe java package of the service interface (e.g. foo in MyService interface before) following our\npackaging conventions.\nIn case these conventions are not met it will fallback to the fully qualified name of the service interface.\n\n\nConfiguration on Level 3 has to be provided as Map argument to the method\nServiceClientFactory.create(Class&lt;S&gt; serviceInterface, Map&lt;String, String&gt; config).\nThe keys of this Map will not use prefixes (such as the ones above). For common configuration\nparameters a type-safe builder is offered to create such map via ServiceClientConfigBuilder.\nE.g. for testing you may want to do:\n\n\n\n\n\n\n\nHere is an example of a configuration block for your application.properties:\n\n\n\n\n\n\n\n\nService Discovery\n\nYou do not want to hardwire service URLs in your code, right? Therefore different strategies might apply\nto discover the URL of the invoked service. This is done internally by an implementation of the interface\nServiceDiscoverer. The default implementation simply reads the base URL from the configuration.\nSo you can simply add this to your application.properties as in the above configuration example.\n\n\nAssuming your service interface would have the fully qualified name\ncom.company.department.foo.mycomponent.service.api.rest.MyService then the URL would be resolved to\nhttps://foo.company.com:8443/services/rest as the «application» is foo.\n\n\nAdditionally, the URL might use the following variables that will automatically be resolved:\n\n\n\n\n${app} to «application» (useful for default URL)\n\n\n${type} to the type of the service. E.g. rest in case of a REST service and ws for a SOAP service.\n\n\n${local.server.port} for the port of your current Java servlet container running the JVM. Should only used for testing with spring-boot random port mechanism (technically spring can not resolve this variable but we do it for you here).\n\n\n\n\nTherefore, the default URL may also be configured as:\n\n\n\n\n\n\n\nAs you can use any implementation of ServiceDiscoverer, you can also easily use eureka (or anything else) instead to discover your services.\nHowever, we recommend to use istio instead as described below.\n\n\n\nHeaders\n\nA very common demand is to tweak (HTTP) headers in the request to invoke the service. May it be for security (authentication data) or for other cross-cutting concerns (such as the Correlation ID). This is done internally by implementations of the interface  ServiceHeaderCustomizer.\nWe already provide several implementations such as:\n\n\n\n\nServiceHeaderCustomizerBasicAuth for basic authentication (auth=basic).\n\n\nServiceHeaderCustomizerOAuth for OAuth: passes a security token from security context such as a JWT via OAuth (auth=oauth).\n\n\nServiceHeaderCustomizerAuthForward forwards the Authorization HTTP header from the running request to the request to the remote serivce as is (auth=authForward). Be careful to avoid security pitfals by misconfiguring this feature as it may also sensitive credentials (e.g. basic auth) to the remote service. Never use as default.\n\n\nServiceHeaderCustomizerCorrelationId passed the Correlation ID to the service request.\n\n\n\n\nAdditionally, you can add further custom implementations of ServiceHeaderCustomizer for your individual requirements and additional headers.\n\n\n\nTimeouts\n\nYou can configure timeouts in a very flexible way. First of all you can configure timeouts to establish the connection (timeout.connection) and to wait for the response (timeout.response) separately. These timeouts can be configured on all three levels as described in the configuration section above.\n\n\n\nError Handling\n\nWhilst invoking a remote service an error may occur. This solution will automatically handle such errors and map them to a higher level ServiceInvocationFailedException. In general we separate two different types of errors:\n\n\n\n\nNetwork error\nIn such case (host not found, connection refused, time out, etc.) there is not even a response from the server. However, in advance to a low-level exception you will get a wrapped ServiceInvocationFailedException (with code ServiceInvoke) with a readable message containing the service that could not be invoked.\n\n\nService error\nIn case the service failed on the server-side the error result will be parsed and thrown as a ServiceInvocationFailedException with the received message and code.\n\n\n\n\nThis allows to catch and handle errors when a service-invocation failed. You can even distinguish business errors from the server-side from technical errors and implement retry strategies or the like.\nFurther the created exception contains detailed contextual information about the serivce that failed (service interface class, method, URL) what makes it much easier to trace down errors. Here is an example from our tests:\n\n\n\n\n\n\n\nYou may even provide your own implementation of ServiceClientErrorFactory instead to provide an own exception class for this purpose.\n\n\nHandling Erros\n\nIn case of a synchronous service invocation an error will be immediately thrown so you can sourround the call with a regular try-catch block:\n\n\n\n\n\n\n\nIf you are using asynchronous service invocation an error can occurr in a separate thread. Therefore you may and should define a custom error handler:\n\n\n\n\n\n\n\nThe error handler consumes Throwable and not only RuntimeException so you can get notified even in case of an unexpected OutOfMemoryError, NoClassDefFoundError, or other technical problems. Please note that the error handler may also be called from the thread calling the service (e.g. if already creating the request fails). The default error handler used if no custom handler is set will only log the error and do nothing else.\n\n\n\n\nLogging\n\nBy default this solution will log all invocations including the URL of the invoked service, success or error status flag and the duration in seconds (with decimal nano precision as available). Therefore you can easily monitor the status and performance of the service invocations. Here is an example from our tests:\n\n\n\n\n\n\n\n\nResilience\n\nResilience adds a lot of complexity and that typically means that addressing this here would most probably result in not being up-to-date and not meeting all requirements. Therefore we recommend something completely different: the sidecar approach (based on sidecar pattern). This means that you use a generic proxy app that runs as a separate process on the same host, VM, or container of your actual application. Then in your app you are calling the service via the sidecar proxy on localhost (service discovery URL is e.g. http://localhost:8081/${app}/services/${type}) that then acts as proxy to the actual remote service. Now aspects such as resilience with circuit breaking and the actual service discovery can be configured in the sidecar proxy app and independent of your actual application. Therefore, you can even share and reuse configuration and experience with such a sidecar proxy app even across different technologies (Java, .NET/C#, Node.JS, etc.). Further, you do not pollute the technology stack of your actual app with the infrastructure for resilience, throttling, etc. and can update the app and the side-card independently when security-fixes are available.\n\n\nVarious implementations of such sidecar proxy apps are available as free open source software.\nOur recommendation in devonfw is to use istio. This not only provides such a side-car but also an entire management solution for service-mesh making administration and maintenance much easier. Platforms like OpenShift support this out of the box.\n\n\nHowever, if you are looking for details about side-car implementations for services you can have a look at the following links:\n\n\n\n\nNetflix Sidecar - see Spring Cloud Netflix docs\n\n\nEnvoy - see Microservices Patterns With Envoy Sidecar Proxy\n\n\nPrana - see Prana: A Sidecar for your Netflix PaaS based Applications and Services ← Not updated as it’s not used internally by Netflix\n\n\nKeycloak - see Protecting Jaeger UI with a sidecar security proxy\n\n\n\n\n\n\n\n\n\n"}